# Защита от повтора

Защита от повтора - это механизм предотвращения атак повторного воспроизведения, которые заключаются в том, что злоумышленник повторно отправляет уже выполненную транзакцию (в данном документе часто сокращается до "tx") в Namada ledger.

Атака повторного воспроизведения приводит к отклонению состояния машины от запланированного (с точки зрения сторон, участвовавших в исходной транзакции) и наносит экономический ущерб плательщику первоначальной транзакции, который оказывается плательщиком более одного раза. Дополнительный экономический ущерб наносится в том случае, если транзакция включала в себя перемещение ценности в той или иной форме (например, перевод токенов), при этом отправитель лишается большей ценности, чем предполагалось.

Поскольку исходная транзакция уже была отформатирована в соответствии с правилами протокола, злоумышленнику не нужно ее переделывать, что делает эту атаку относительно простой.

Конечно, атака на воспроизведение имеет смысл только в том случае, если атакующий отличается от источника исходной транзакции, так как пользователь всегда сможет сгенерировать другую семантически идентичную транзакцию для отправки без необходимости воспроизведения той же самой транзакции.

Для предотвращения такого сценария Namada поддерживает механизм защиты от повторного воспроизведения, предотвращающий выполнение уже обработанных транзакций.

### Контекст&#x20;

В данном разделе показан существующий контекст, в котором реализуется механизм защиты от воспроизведения.

#### Шифрование-аутентификация&#x20;

Текущая реализация Namada построена на базе CometBFT, которая обеспечивает шифрованный и аутентифицированный канал связи между двумя узлами для предотвращения атаки _man-in-the-middle_ (см. подробную спецификацию).

Протокол Namada опирается на эту подложку для обмена транзакциями (сообщениями), которые определяют переход состояния Namada ledger. Более конкретно, транзакция состоит из двух частей:  `WrapperTx` и внутренней части `Tx`

```rust
pub struct WrapperTx {
  /// The fee to be payed for including the tx
  pub fee: Fee,
  /// Used to determine an implicit account of the fee payer
  pub pk: common::PublicKey,
  /// The epoch in which the tx is to be submitted. This determines
  /// which decryption key will be used
  pub epoch: Epoch,
  /// Max amount of gas that can be used when executing the inner tx
  pub gas_limit: GasLimit,
  /// The optional unshielding tx for fee payment
  pub unshield: Option<Tx>,
  /// the encrypted payload
  pub inner_tx: EncryptedTx,
  /// sha-2 hash of the inner transaction acting as a commitment
  /// the contents of the encrypted payload
  pub tx_hash: Hash,
}
 
pub struct Tx {
  pub code: Vec<u8>,
  pub data: Option<Vec<u8>>,
  pub timestamp: DateTimeUtc,
}
```

Wrapper - транзакция состоит из некоторых метаданных, необязательного неэкранированного Tx для оплаты комиссии (см. спецификацию комиссии), самой зашифрованной внутренней транзакции и хэша конкатенации этих значений. Внутренняя транзакция Tx несет в себе код Wasm, который должен быть выполнен, и связанные с ним данные.

Транзакция строится следующим образом:

1. Создается структура `Tx`&#x20;
2. Хеш этой транзакции подписывается автором, в результате чего образуется еще один `Tx`, в поле данных которого содержится конкатенация исходных данных и подписи (`SignedTxData`)
3. Полученная транзакция шифруется и встраивается в `WrapperTx`. Шаг шифрования существует для будущей реализации пороговой схемы дешифрования (см. Ferveo).
4. Наконец, `WrapperTx` преобразуется в `Tx`-структуру, подписывается по хэшу (аналогично шагу 2, с использованием `SignedTxData`) и передается в сеть

Заметим, что подписант `WrapperTx` и подписант внутренней части не обязательно должны совпадать, но за подписанта Wrapper взимается плата за газ и сборы. На этапах выполнения:

1. Проверяется подпись `WrapperTx` и, только если она действительна, tx обрабатывается.
2. На следующей высоте предлагающий расшифровывает внутренний tx, проверяет соответствие хэша полю `tx_hash` и, если все прошло успешно, включает расшифрованный tx в предлагаемый блок.&#x20;
3. После этого внутренний tx будет выполнен средой исполнения WASM.&#x20;
4. После выполнения затронутые предикаты валидности (в данном документе также упоминаемые как VP) проверят изменения в хранилище и (если это уместно) подпись транзакции: если подпись не является валидной, VP посчитает транзакцию недействительной, и изменения не будут применены к хранилищу.

Проверка подписи эффективно предотвращает подделку данных транзакции, так как любая такая подделка приведет к сбою проверки и отказу от транзакции. Более подробная информация приведена в спецификации выполнения Namada.

### Защита от повтора CometBFT

Первый уровень защиты обеспечивается в mempool базового механизма консенсуса CometBFT, который основан на кэше ранее просмотренных транзакций. Этот механизм направлен на то, чтобы предотвратить включение уже обработанной транзакции в следующий блок со стороны предлагающего блок, что может произойти при позднем поступлении транзакции. Разумеется, это также является мерой противодействия преднамеренным атакам повторного воспроизведения. Однако эта проверка, как и все проверки, выполняемые в `CheckTx`, является слабой, поскольку блок, содержащий недействительные транзакции, все равно может быть предложен злонамеренным валидатором. Поэтому необходим более надежный механизм защиты от воспроизведения, реализованный непосредственно в приложении.

### Реализация&#x20;

Защита от повторного воспроизведения Namada состоит из трех частей: решения на основе хэшей для `EncryptedTx` (также называемого `InnerTx`) и `WrapperTx`, способа защиты от атак повторного воспроизведения в случае форка, а также концепции времени жизни транзакций.

#### Хэш-регистр&#x20;

Собственно Wasm-код и данные для транзакции инкапсулируются в struct `Tx`, который шифруется как `EncryptedTx` и оборачивается в `WrapperTx` (см. соответствующий раздел). Эта внутренняя транзакция должна быть защищена от атак повторного воспроизведения, поскольку она несет в себе фактическую семантику перехода состояния. Более того, даже если обернутая транзакция будет защищена от атак на воспроизведение, внутренняя транзакция все равно может быть извлечена злоумышленником, искажена и воспроизведена. Следует отметить, что для успешного проведения такой атаки злоумышленнику потребуется самостоятельно подписать внешнюю транзакцию и заплатить за это газ и комиссионные. Однако это все равно может нанести значительный ущерб сторонам, участвовавшим во внутренней транзакции.

`WrapperTx` - это единственный тип транзакций, который в настоящее время принимается Namada ledger. Она должна быть защищена от атак повторного воспроизведения; в противном случае злоумышленник может воспроизвести транзакцию как есть. Даже если бы внутренняя транзакция имела защиту от воспроизведения или не была бы принята по какой-либо причине, подписант обернутой транзакции все равно понес бы расходы на газ и комиссионные, что привело бы к экономическому ущербу.

Для предотвращения повторного воспроизведения обеих транзакций используется набор дайджестов уже обработанных транзакций, хранящихся в памяти. Эти дайджесты вычисляются для неподписанных транзакций, чтобы обеспечить защиту от воспроизведения даже для многоподписных транзакций. В этом случае использование хэшей от подписанных транзакций привело бы к тому, что для разных наборов подписей одной и той же транзакции был бы получен другой хэш, что позволило бы воспроизвести ее. Для этого в хэш-поле `WrapperTx` вместо хэша подписанной транзакции помещается хэш неподписанной внутренней транзакции. Это изменение не влияет на общую безопасность Namada, так как обернутая транзакция по-прежнему подписывается всеми своими байтами, включая внутреннюю подпись. Модификация также позволяет осуществлять раннюю проверку на атаки воспроизведения в mempool и при включении обернутой транзакции в блок.

Кроме того, требуется подпространство в памяти, возглавляемое внутренним адресом `ReplayProtection`:

```rust
/\$ReplayProtectionAddress/\$tx0_hash: None
/\$ReplayProtectionAddress/\$tx1_hash: None
/\$ReplayProtectionAddress/\$tx2_hash: None
...
```

Хеши располагаются в конце пути, чтобы обеспечить быстрый поиск в хранилище.

Согласованность подпространства хранения очень важна для корректной работы механизма защиты от воспроизведения. Для ее обеспечения предикат валидности проверяет, что никакие транзакции wasm не вносят изменений в это подпространство, поскольку эти изменения должны исходить только от протокола.

В `mempool_validation` и `process_proposal` выполняется проверка (в сочетании с другими проверками, описанными в соответствующем разделе) дайджестов к хранилищу на предмет того, что ни одна из транзакций еще не была выполнена. Если это условие не выполняется, то `WrapperTx` соответственно не включается в mempool или блок. В `process_proposal`используется временный кэш для предотвращения повторного выполнения транзакции в том же блоке. Если обе проверки пройдены, то транзакция включается в блок. В `finalize_block` хэши фиксируются на хранение, и транзакция выполняется.

В последующем блоке происходит десериализация внутренней транзакции, проверяется валидность расшифрованных транзакций и их правильный порядок. Если порядок неверен, то начинается новый раунд CometBFT. Если в какой-либо отдельной расшифрованной транзакции обнаружена ошибка, то ранее вставленный хэш внутренней транзакции удаляется из хранилища для возможности повторного обертывания, а сама транзакция отбрасывается. Наконец, в блоке `finalize_block` транзакция выполняется. Если в транзакции закончился газ, то ее хэш будет удален из хранилища для повторного обертывания и выполнения транзакции. В противном случае хэш останется в хранилище, независимо от успеха или неудачи транзакции.

#### Дополнительная защита экранирования

Предполагается, что необязательное поле `unshield` несет в себе неэкранируемую masp-транзакцию. Учитывая это предположение, управлять им нет необходимости, поскольку masp имеет внутренний механизм защиты от воспроизведения.

Тем не менее, поскольку это поле представляет действительную транзакцию, существует возможность атаки с использованием этого поля: злоумышленник может извлечь эти данные до того, как они попадут в блок, встроить их в действительный, подписанный masp-транзакцией `Tx` и применить его заранее.

Эта атака выполняется до того, как оригинальный `Tx` будет помещен в блок, и поэтому не может быть предотвращена с помощью механизма защиты от воспроизведения. Единственным результатом такой атаки будет сбой исходной транзакции-обертки, поскольку она попытается воспроизвести masp-передачу: в этом случае отправитель исходного `tx` сможет воссоздать его без необходимости в операции снятия защиты, поскольку атакующий уже выполнил ее.

Учитывая, что сохранение хэша неэкранирующей транзакции является избыточным в случае корректной передачи masp, Namada не реализует механизм защиты от воспроизведения неэкранирующей транзакции, корректность которой зависит от предиката валидности masp. Сочетание системы сборов, набора предикатов достоверности и протокольных проверок операции снятия защиты гарантирует, что даже в случае осуществления атаки, описанной в данном разделе:

* оригинальный подписант обернутой транзакции не понесет экономического ущерба (обертка, содержащая недействительное снятие экранирования, вынуждает отказаться от блока без взимания платы)&#x20;
* злоумышленник вынужден платить комиссионные за повторно обернутые `tx`, что не позволяет ему отправлять эти транзакции бесплатно

#### Предложения по управлению&#x20;

Предложения по управлению могут содержать некоторый wasm-код, который должен быть выполнен в случае принятия предложения. Этот код встраивается в `DecryptedTx` непосредственно валидаторами во время обработки блока и не вставляется в сам блок.

Учитывая, что wasm-код прикреплен к транзакции, инициирующей предложение, он может быть извлечен отсюда и вставлен в транзакцию до того, как предложение будет выполнено. Поэтому защита от повторного воспроизведения не является решением для предотвращения атак на код предложений управления. Вместо этого для защиты таких транзакций Namada использует механизм идентификации предложений в сочетании с набором VP.

#### Транзакции в протоколе

В настоящее время такие транзакции используются только для операций, связанных с мостом ETH. Текущая реализация уже заботится о попытках переигрывания, отслеживая подписи валидаторов на событиях: это касается и атак на переигрывание в том же блоке.

В будущем могут поддерживаться новые типы протокольных транзакций, и в этом случае может потребоваться пересмотр механизма защиты от повторного воспроизведения.

### Форки&#x20;

В случае развилки атаки на воспроизведение не предотвращаются только хэшем транзакций. Транзакции все равно могут быть воспроизведены на другой ветке, если их формат остается неизменным, а счетчики в хранилище совпадают.

Для решения этой проблемы транзакции должны иметь идентификатор `ChainId`, привязывающий их к конкретному форку. Это поле должно быть добавлено в структуру `Tx` таким образом, чтобы оно применялось как к `WrapperTx`, так и к `EncryptedTx`:

```rust
pub struct Tx {
  pub code: Vec<u8>,
  pub data: Option<Vec<u8>>,
  pub timestamp: DateTimeUtc,
  pub chain_id: ChainId
}
```

Это новое поле подписывается так же, как и другие, и поэтому на него распространяются те же гарантии, о которых говорилось в начальном разделе. Действительность этого идентификатора проверяется в `process_proposal` как для внешнего, так и для внутреннего `tx`: как для внешней, так и для внутренней транзакции. Если транзакция несет неожиданный идентификатор цепочки, то она не будет применена, а значит, никакие модификации не будут применены к хранилищу.

### Время жизни транзакции&#x20;

В общем случае транзакция действительна в момент ее подачи, но после этого различные внешние факторы могут изменить намерения подателя. Отправитель может быть больше не заинтересован в выполнении транзакции.

Необходимо ввести понятие времени жизни (или таймаута) транзакций: в структуру `Tx` будет включено дополнительное необязательное поле `expiration`, указывающее максимальное время `DateTimeUtc`, в течение которого отправитель хочет увидеть транзакцию выполненной. По истечении указанного времени транзакция считается недействительной и отбрасывается, независимо от других проверок.

Введение этого нового поля добавляет в контракт транзакции новое ограничение. Регистратор гарантирует, что транзакция не будет выполнена по истечении установленного срока. С другой стороны, отправитель берет на себя обязательства по результату выполнения до истечения срока. Если срок истекает, а транзакция так и не была выполнена, то отправитель может принять решение о подаче новой транзакции, если он по-прежнему заинтересован в изменениях, которые она несет.

В текущем проекте срок действия истекает до тех пор, пока транзакция не будет выполнена. После выполнения хэш транзакции фиксируется в хранилище, предотвращая дальнейшее повторение (независимо от того, был ли `tx` успешным или нет). По сути, отправитель транзакции принимает на себя обязательство выполнить одно из этих трех условий:

* Транзакция недействительна, независимо от конкретного состояния&#x20;
* Транзакция выполнена (успешно или нет), и хэш транзакции сохранен в хранилище&#x20;
* Пришло время истечения срока действия

Любое выполненное условие делает недействительными последующие выполнения той же транзакции.

```rust
pub struct Tx {
  pub code: Vec<u8>,
  pub data: Option<Vec<u8>>,
  pub timestamp: DateTimeUtc,
  pub chain_id: ChainId,
  /// Optional lifetime of the transaction
  pub expiration: Option<DateTimeUtc>,
}
```

Обернутая транзакция должна совпадать с истечением срока действия внутренней транзакции (если таковая имеется). Это поле также необходимо для того, чтобы обертка могла предвидеть проверку во время оценки mempool/предложения. Кроме того, оно не позволяет вставить транзакцию-обертку после истечения срока действия соответствующей внутренней транзакции, что вынуждает подписавшего обернутую транзакцию платить комиссионные.

### Проверки обёрнутой транзакции&#x20;

В mempool\_validation для проверки обернутой транзакции выполняется несколько проверок. К этим проверкам относятся:

* Подпись&#x20;
* GasLimit ниже лимита газа в блоке&#x20;
* Комиссия оплачена принятым токеном и соответствует минимально необходимой сумме
* ChainId&#x20;
* Хэш транзакции&#x20;
* Срок действия&#x20;
* Достаточно ли средств у подписанта для оплаты комиссии&#x20;
* Неэкранирующая транзакция (если присутствует) является действительным неэкранирующим переводом masp&#x20;
* Неэкранирующая транзакция (если присутствует) высвобождает минимально необходимое количество токенов для оплаты комиссии&#x20;
* Успешное выполнение неэкранирующей транзакции (если она присутствует)

Более подробная информация о газе, комиссионных сборах и операции по снятию экранирования приведена в спецификации тарифов.

Все эти проверки могут проводиться до выполнения самих транзакций. Если какая-либо из этих проверок не проходит, транзакция считается недействительной, и предпринимаются соответствующие действия:

1. Если проверка подписи, `chainId`, срока действия, хэша транзакции, баланса или неэкранирующей транзакции не проходит, то транзакция считается окончательно недействительной. Ее не нужно включать в блок. Более того, включение транзакции в блок для начисления платы (в качестве наказания) невозможно, так как эти ошибки могут возникать не по вине подписавшего транзакцию (могут быть вызваны злоумышленниками или просто задержкой включения транзакции в блок).
2. Если проверка на `Fee` или `GasLimit` не проходит, транзакция отменяется. Теоретически газовый лимит блока - это параметр Namada, регулируемый управлением. Таким образом, транзакция может стать действительной в будущем, если этот лимит будет увеличен. Тот же принцип применим к "белому списку" токенов и минимальной требуемой комиссии. Однако ожидается, что эти параметры будут меняться медленно, поэтому отклонение транзакции вполне обоснованно (инициатор всегда может повторно подать ее в будущем).

Если все проверки пройдены, транзакция включается в блок для хранения хэша и применения комиссии.

Все эти проверки также выполняются в `process_proposal`.

Этот механизм можно применить и к другому сценарию. Предположим, что транзакция не была распространена в сети узлом (или группой сговорившихся узлов). Эта транзакция может быть действительной, но она не вставлена в блок. Без истечения срока действия эта транзакция может быть воспроизведена (точнее, применена, поскольку она никогда не выполнялась) в более позднее время, когда отправитель, возможно, уже не захочет ее выполнять.

### Отклонение блока&#x20;

Чтобы предотвратить включение в блок недействительных транзакций со стороны предлагающего блок, валидаторы отклоняют весь блок, если встречают хоть одну недействительную обернутую транзакцию.

Отклонение только одной недействительной транзакции при сохранении возможности принятия всего блока является неадекватным решением. В этом случае у разработчика блока нет мотивации включать в блок недействительные транзакции, так как они не приносят никакой платы. Но в то же время у разработчика нет реальных стимулов для исключения таких транзакций. В таких случаях валидаторы просто отбрасывают недействительную транзакцию, одобряя остальную часть блока, что позволяет автору предложения взимать плату со всех остальных транзакций. Разумеется, данное обстоятельство имеет место в тех случаях, когда у предлагающего нет других действительных транзакций, которые можно было бы включить в блок. Вредоносный автор может использовать эту стратегию для наполнения блока спамом без каких-либо штрафных санкций.

В целом блок может быть отклонен, если выполняется хотя бы одно из следующих условий:

* одна или несколько транзакций `WrapperTx` недействительны в соответствии с проверками, описанными в соответствующем разделе&#x20;
* порядок или количество расшифрованных транзакций отличается от порядка или количества транзакций, совершенных в предыдущем блоке
