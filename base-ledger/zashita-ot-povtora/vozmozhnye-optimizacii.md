# Возможные оптимизации

В этом разделе мы описываем два альтернативных решения, которые содержат некоторые оптимизации.

### Счетчик транзакций&#x20;

Вместо хэша (32 байта) Namada может использовать 64-битный (8 байт) счетчик транзакций в качестве `nonce` для обернутых и внутренних транзакций. Преимущество заключается в том, что для этого потребуется гораздо меньше места, поскольку для каждого адреса, подписывающего транзакции, необходимо хранить только два значения по 8 байт. С другой стороны, работа со счетчиком для внутренней транзакции выполняется полностью в wasm (транзакции и VP), что делает ее несколько менее эффективной. Кроме того, такое решение накладывает строгий порядок на транзакции, выданные по одному адресу.

{% hint style="info" %}
<mark style="color:blue;">Это решение требует возможности выдавать исполнение от Wasmer, что не реализовано.</mark>
{% endhint %}

### Внутренние Tx&#x20;

Мы реализуем защиту полностью в Wasm: проверка счетчика будет осуществляться предикатами валидности, а фактическая запись счетчика в хранилище будет осуществляться самими транзакциями.

Для этого в `SignedTxData`, прикрепленном к транзакции, будет храниться текущее значение счетчика:

```rust
pub struct SignedTxData {
  /// The original tx data bytes, if any
  pub data: Option<Vec<u8>>,
  /// The optional transaction counter for replay protection
  pub tx_counter: Option<u64>,
  /// The signature is produced on the tx data concatenated with the tx code
  /// and the timestamp.
  pub sig: common::Signature,
}
```

Счетчик должен находиться в `SignedTxData`, а не в самих данных, поскольку это должно проверяться предикатом валидности, который не знает, какая именно транзакция произошла, а только изменения в хранилище; поэтому VP не может корректно десериализовать данные транзакций, так как не знает, какой тип данных представляют байты.

Счетчик также будет подписан, чтобы защитить его от взлома и предоставить ему те же гарантии, о которых говорилось в начале этого документа.

Транзакция wasm будет просто считывать значение из хранилища и увеличивать его на единицу. Целевой ключ в хранилище будет иметь следующий вид:

```rust
/$Address/inner_tx_counter: u64
```

Затем VP исходного адреса проверит действительность подписи и, если она будет признана действительной, проверит, было ли предварительное значение счетчика в хранилище равно значению, содержащемуся в структуре `SignedTxData`, и было ли увеличено на единицу постзначение ключа в хранилище: если одно из этих условий не выполняется, то VP отменит транзакции и не позволит применить изменения к хранилищу.

В конкретном случае экранированной передачи, поскольку MASP уже имеет защиту от повторного воспроизведения как часть дизайна Zcash (см. спецификации MASP и Zcash protocol specs), счетчик в `SignedTxData` не требуется и поэтому должен быть опциональным.

Для реализации защиты от воспроизведения для внутренней транзакции необходимо обновить все VP, проверяющие подпись транзакции, чтобы они включали проверку счетчика транзакций: на данный момент обновлению подлежит только предикат достоверности `vp_user`. Кроме того, все транзакции с `SignedTxData` должны инкрементировать счетчик.

### Обернутые Tx

Для защиты этой транзакции мы можем реализовать внутрипротокольный механизм. Поскольку обернутая транзакция подписывается перед отправкой в сеть, мы можем использовать поле `tx_counter` в `SignedTxData`, уже введенное для внутреннего `tx`.

Кроме того, нам необходим еще один счетчик в подпространстве хранения каждого адреса:

```rust
/$Address/wrapper_tx_counter: u64
```

где `$Address` - тот, кто подписывает транзакцию (он же подразумевается полем pk структуры `WrapperTx`).

Проверка будет состоять сначала из проверки подписи, а затем из проверки счетчика, которая позволит убедиться, что счетчик, прикрепленный к транзакции, совпадает со счетчиком, хранящимся для адреса подписи. Это будет сделано в функции `process_proposal`, чтобы валидаторы могли решить, является ли транзакция валидной или нет; если нет, то они отбрасывают эту транзакцию и переходят к следующей.

Наконец, в блоке `finalize_block` Namada ledger обновит ключ счетчика в хранилище, увеличив его значение на единицу. Это произойдет при выполнении следующих условий:

* `process_proposal` принял `tx`, проверив его подпись и счетчик транзакций&#x20;
* `tx` был правильно применен в `finalize_block` (для `WrapperTx` это означает просто включение в блок и учет газа)

Теперь, если злоумышленник попытается воспроизвести эту транзакцию, счетчик `tx_counter` в struct уже не будет равен счетчику в хранилище, и транзакция будет считаться недействительной.

### Детали реализации&#x20;

В этом разделе мы расскажем о некоторых деталях механизма защиты от воспроизведения, которые вытекают из решения, предложенного в данном разделе.

#### Счетчики хранилища&#x20;

Защита от воспроизведения требует взаимодействия с хранилищем как со стороны протокола, так и со стороны Wasm. Для этого мы можем воспользоваться преимуществами признаков `StorageRead` и `StorageWrite`, чтобы работать с единым интерфейсом.

Данная реализация требует наличия в хранилище двух счетчиков транзакций для каждого адреса, так что подпространство хранилища для данного адреса выглядит следующим образом:

```rust
/$Address/wrapper_tx_counter: u64
/$Address/inner_tx_counter: u64
```

Реализация, требующая наличия в хранилище одного счетчика, была рассмотрена и отброшена, поскольку в этом случае не поддерживается пакетная обработка; более подробное объяснение см. в разделе.

Как для обернутой, так и для внутренней транзакции увеличение счетчика в хранилище является важным шагом, который должен быть выполнен корректно. Во-первых, реализация будет возвращать ошибку в случае переполнения счетчика, чтобы предотвратить обертывание, поскольку это позволит воспроизвести предыдущие транзакции. Кроме того, мы хотим увеличить счетчик, как только убедимся, что подпись, идентификатор цепочки и переданный счетчик транзакций действительны. Увеличение должно происходить сразу после проверки по двум причинам:

* Предотвращение атаки повторного воспроизведения транзакции в том же блоке
* Обновление счетчика транзакций даже в случае неудачи транзакции для предотвращения возможной атаки повторного воспроизведения в будущем (так как транзакция, недействительная в состоянии `Sx`, может стать действительной в состоянии `Sn`, где n > x)

Для `WrapperTx` увеличение счетчика и учет платы будут выполняться в блоке `finalize_block` (как указано в соответствующем разделе).

Для внутренней Tx логика не совсем однозначна. Код транзакции будет выполняться в среде Wasm (Wasmer) до тех пор, пока не завершится или не вызовет исключение. В случае успеха счетчик в хранилище будет корректно обновлен, но в случае неудачи протокол отбросит все изменения, внесенные транзакциями в журнал записи, включая обновленный счетчик транзакций. Это является проблемой, поскольку транзакция может быть успешно воспроизведена в будущем, если она станет валидной.

Идеальным решением было бы прерывание выполнения кода Wasm после увеличения счетчика транзакций (если таковой имеется). Это позволило бы выполнить первый прогон задействованных VP и, если все они согласны с изменениями, дать протоколу возможность зафиксировать эти изменения до возможного сбоя. После этого протокол возобновит выполнение транзакции с предыдущей точки прерывания до завершения или отказа, после чего инициируется второй проход VP для подтверждения оставшихся модификаций состояния. В случае отклонения VP после увеличения счетчика возобновлять выполнение не нужно, и транзакция может быть сразу признана недействительной, чтобы протокол мог перейти к следующему tx для выполнения. При таком решении обновление счетчика будет зафиксировано в памяти независимо от сбоя самой транзакции.

К сожалению, в настоящее время Wasmer не позволяет выходить из исполнения.

В случае если транзакция вышла за пределы газа (с учетом поля `gas_limit` ), все примененные изменения будут удалены из WAL и не повлияют на состояние хранилища. Затем внутренняя транзакция может быть повторно обернута с корректным лимитом газа и воспроизведена до истечения срока действия.

#### Пакетирование и упорядочивание транзакций&#x20;

Данная технология защиты от воспроизведения поддерживает выполнение нескольких транзакций с одним и тем же адресом источника в одном блоке. Фактически, наличие счетчиков транзакций и выполняемые по ним проверки теперь накладывают строгий порядок на последовательность выполнения (что может быть дополнительным преимуществом для некоторых случаев использования). Корректное выполнение более чем одной транзакции по адресу источника в одном блоке сохраняется до тех пор, пока:

1. Обернутые транзакции вставляются в блок с правильным порядком возрастания&#x20;
2. В последовательности счетчиков нет дыр&#x20;
3. Счетчик первого транзакта, включенного в блок, совпадает с ожидаемым счетчиком в хранилище

Эти условия навязываются автором блока, который заинтересован в максимизации суммы сборов, извлекаемых предлагаемым блоком. Чтобы поддержать этот стимул, валидаторы будут отклонять предложенный блок, если какая-либо из включенных в него транзакций-оберток окажется недействительной, что фактически стимулирует автора блока включать только действительные транзакции и правильно их упорядочивать для получения вознаграждения.

В случае если пропущенная транзакция приводит к появлению бреши в последовательности счетчиков транзакций, автор блока включает в блок все транзакции до пропущенной и отбрасывает все следующие за ней, эффективно сохраняя правильную упорядоченность.

Правильное упорядочивание транзакций не гарантирует их корректного выполнения. Как уже говорилось в разделе `WrapperTx`, автору блока и валидаторам также необходимо обращаться к хранилищу, чтобы проверить, что первый счетчик транзакций в последовательности действительно является ожидаемым.

Весь процесс упорядочивания счетчиков происходит только на `WrapperTx`: если внутренний счетчик неверен, то внутренняя транзакция завершится неудачей, а с подписанта соответствующей обертки будут взысканы комиссионные. Это стимулирует отправителей к созданию корректных транзакций и препятствует злоумышленникам в повторной обертке и повторной отправке старых транзакций.

#### Проверки mempool&#x20;

В качестве оптимизации для предотвращения спама в mempool некоторые проверки, введенные в этом документе, будут перенесены и в функцию `mempool_validate`. Разумеется, речь всегда идет только о проверках на `WrapperTx`. Более конкретно:

* Проверка поля `ChainId`&#x20;
* Проверка подписи транзакции по полю pk в `WrapperTx`&#x20;
* Выполнить ограниченную проверку счетчика транзакций

Что касается последнего пункта, то mempool\_validate будет проверять, является ли счетчик в транзакции >=, чем счетчик в хранилище для адреса, подписывающего `WrapperTx`. Полная проверка (проверка на строгое равенство) не представляется возможной, о чем говорится в этом разделе.

### Рассмотренные альтернативы&#x20;

В этом разделе перечислены возможные решения, которые рассматривались при написании данного решения, но в итоге были отброшены.

#### Проверка счетчиков транзакций в Mempool&#x20;

Идея выполнения полной проверки счетчиков транзакций в функции `mempool_validate` была отброшена из-за возможного недостатка.

Предположим, клиент посылает пять транзакций (счетчики от 1 до 5). Не гарантируется, что мемпул следующего предлагающего блок будет получать их по порядку: что-то в сети может перетасовать транзакции так, что они придут в следующем порядке: 2-3-4-5-1. Теперь, поскольку мы проверяем каждую транзакцию на включение в пул именно в том порядке, в котором мы их получаем, мы отбросим первые четыре транзакции и примем только последнюю, со счетчиком 1. Теперь следующий автор блока может иметь в своем мемпуле четыре отброшенных транзакции (поскольку они не были добавлены в предыдущий блок и, следовательно, не были вытеснены из других мемпулов, по крайней мере, не должны, см. раздел "Отказ от блока") и поэтому может включить их в следующий блок. Но все равно процесс, который мог бы завершиться за один блок, на самом деле занял два блока. Кроме того, есть еще две проблемы:

* Следующий автор блока может иметь оставшиеся транзакции не по порядку в своем пуле, что приведет к распространению той же проблемы до следующего автора блока.
* Следующий автор блока может вообще не иметь этих транзакций в своем пуле памяти

Наконец, транзакции, не допущенные в mempool, не распространяются среди других пиров, что еще больше затрудняет их включение в блок. Поэтому лучше отказаться от полной фильтрации транзакций по их порядку в mempool: вместо этого мы выполним более простую проверку, а затем позволим автору блока правильно переставлять их при предложении блока.

#### Внутрипротокольная защита для InnerTx(внутренних транзакций)

В альтернативном варианте защита внутреннего tx может быть размещена в протоколе, как и в обертке, на основе счетчика транзакций внутри `SignedTxData`. Проверка будет выполняться в `process_proposal`, а обновление - в `finalize_block`, как и для транзакции-обертки. Однако такая реализация имеет два недостатка:

* это предполагает необходимость жесткого форка в случае модификации механизма защиты от повторного воспроизведения&#x20;
* извне неясно, кто является источником внутренней транзакции, поскольку это зависит от конкретного кода самой транзакции. Мы могли бы использовать специфический набор белых txs для определения того, когда требуется счетчик (это не будет работать для будущих программируемых транзакций), но все равно у нас нет возможности определить, какой адрес должен быть направлен на защиту от воспроизведения (проблема блокировки)

#### Внутрипротокольное увеличение счетчика для InnerTx&#x20;

В разделе, посвященном счетчикам хранения, мы упоминали о проблеме увеличения счетчика транзакций для внутреннего `tx` даже в случае сбоя. Возможным решением, которое мы рассмотрели и отбросили, было увеличение счетчика из протокола в случае сбоя.

Это технически возможно, поскольку протоколу известны ключи, модифицированные транзакцией, а также результаты предикатов валидности (полезно в случае, если транзакция обновила более одного счетчика в хранилище). В этом случае можно восстановить значение и повторно применить изменение непосредственно из протокола. Такая логика, однако, является достаточно дисперсионной, поскольку фактически разделяет управление счетчиком для `InnerTx` между Wasm и протоколом, в то время как изначально мы хотели полностью оставить его в Wasm.

#### Одиночный счетчик в хранилище&#x20;

Мы не можем использовать один счетчик транзакций в хранилище, поскольку это препятствует пакетной обработке.

Например, если клиент (с текущим счетчиком в хранилище, имеющим значение 5) генерирует две транзакции, которые будут включены в один блок, подписывая как внешнюю, так и внутреннюю (поведение клиента по умолчанию), то ему потребуется сгенерировать следующие счетчики транзакций:

```rust
[
    T1: (WrapperCtr: 5, InnerCtr: 6),
    T2: (WrapperCtr: 7, InnerCtr: 8)
]
```

Итак, текущая модель выполнения Namada предусматривает сначала выполнение `WrapperTx` в блоке, а затем расшифровку и выполнение внутреннего tx в следующем блоке (с соблюдением порядка фиксации транзакций). Это означает, что внешний tx из T1 пройдет проверку и немедленно увеличит счетчик до 6, чтобы предотвратить атаку повторного воспроизведения в том же блоке. Теперь будет обработан внешний tx от T2, но он не пройдет проверку, поскольку несет счетчик со значением 7, в то время как ledger ожидает 6.

Чтобы решить эту проблему, можно установить счетчики следующим образом:

```rust
[
    T1: (WrapperCtr: 5, InnerCtr: 7),
    T2: (WrapperCtr: 6, InnerCtr: 8)
]
```

Таким образом, обе транзакции будут считаться действительными и выполняться. Проблема заключается в том, что если вторая транзакция не будет включена в блок (по какой-либо причине), то первая транзакция (единственная оставшаяся на данный момент) завершится неудачей. На самом деле, после того как внешний tx корректно увеличил счетчик в хранилище до значения 6, блок будет принят. В следующем блоке внутренняя транзакция будет расшифрована и выполнена, но этот последний шаг будет неудачным, так как счетчик в `SignedTxData` имеет значение 7, а счетчик в хранилище - 6.

Справиться с этим можно двумя способами. Первый - вместо того, чтобы проверять точное значение счетчика в хранилище и увеличивать его на единицу, можно проверить, что транзакция несет счетчик >=, чем в хранилище, и записать его (не увеличивая) в хранилище. Проблема здесь заключается в отсутствии поддержки строгого упорядочивания выполнения.

Второй вариант - сохранить обычную стратегию увеличения счетчика (увеличение на единицу и проверка на строгое равенство) и просто использовать два разных счетчика в хранилище для каждого адреса. Тогда транзакция будет выглядеть следующим образом:

```rust
[
    T1: (WrapperCtr: 5, InnerCtr: 5),
    T2: (WrapperCtr: 6, InnerCtr: 6)
]
```

Поскольку порядок включения `WrapperTxs` вынуждает соблюдать тот же порядок выполнения для внутренних, оба транзакта могут быть корректно выполнены, и корректность сохранится даже в том случае, если T2 не попал в блок (заметим, что счетчик для внутреннего tx и соответствующего ему оберточного не обязательно должен совпадать).

### Обернутый InnerTx

Решением является привязка `InnerTx` к соответствующему `WrapperTx`. Таким образом, становится невозможным перевернуть внутреннюю транзакцию и, следовательно, все атаки, связанные с такой практикой, будут неосуществимы. Этот механизм требует еще меньше места в хранилище (только 64-битный счетчик для каждого адреса, подписывающего транзакции-обертки) и только одну проверку счетчика оберток в протоколе. В то же время он требует связи между подписывающим внутреннюю транзакцию и подписывающим транзакцию-обертку во время построения транзакции. Кроме того, такое решение накладывает строгий порядок на транзакции-обертки, выданные по одному и тому же адресу.

Для этого нам придется изменить текущее определение двух структур tx на следующее:

```rust
pub struct WrapperTx {
  /// The fee to be payed for including the tx
  pub fee: Fee,
  /// Used to determine an implicit account of the fee payer
  pub pk: common::PublicKey,
  /// Max amount of gas that can be used when executing the inner tx
  pub gas_limit: GasLimit,
  /// Lifetime of the transaction, also determines which decryption key will be used
  pub expiration: DateTimeUtc,
  /// Chain identifier for replay protection
  pub chain_id: ChainId,
  /// Transaction counter for replay protection
  pub tx_counter: u64,
  /// the encrypted payload
  pub inner_tx: EncryptedTx,
}
 
pub struct Tx {
  pub code: Vec<u8>,
  pub data: Option<Vec<u8>>,
  pub timestamp: DateTimeUtc,
  pub wrapper_commit: Option<Hash>,
}
```

Транзакция-обертка больше не хранит хэш внутренней транзакции, а внутренняя транзакция теперь хранит фиксацию соответствующей транзакции-обертки tx в виде хэша структуры `WrapperCommit`, определяемой как:

```rust
pub struct WrapperCommit {
  pub pk: common::PublicKey,
  pub tx_counter: u64,
  pub expiration: DateTimeUtc,
  pub chain_id: ChainId,
}
```

Пара `pk-tx_counter`, содержащаяся в этой структуре, однозначно идентифицирует один `WrapperTx` (поскольку правильный `tx_counter` уникален, учитывая адрес), так что внутренний теперь привязан к этой конкретной обертке. Остальные поля, `expiration` и `chain_id`, будут связывать эти два значения, учитывая их важность с точки зрения безопасности (см. раздел). Заметим, что поле `wrapper_commit` должно быть необязательным, поскольку сама структура `WrapperTx` перед отправкой преобразуется в структуру Tx, но в обязательствах не нуждается.

И внутренний tx, и tx обертки, как обычно, подписываются хэшем, чтобы предотвратить фальсификацию данных. Когда обёртка обрабатывается ledger, мы сначала проверяем достоверность подписи, убеждаясь, что ни одно из полей не было изменено: это означает, что внутренний tx, встроенный в обёртку, действительно является тем, для которого она предназначена. Последнее утверждение означает, что внешний злоумышленник не подделал данные, но подделка все равно могла быть произведена подписавшим обертку до подписания транзакции с оберткой.

Если эта проверка (и другие, о которых будет рассказано далее в разделе "Проверки") пройдена, то внутренний tx расшифровывается в следующем процессе предложения блоков. В это время мы проверяем, что порядок вставки внутренних транзакций в блок совпадает с порядком вставки соответствующих tx обертки в предыдущий блок. Для этого мы опираемся на очередь внутри хранилища, содержащую хэш структуры `WrapperCommit`, вычисленный из оберточного tx. Из внутреннего tx мы извлекаем хэш `WrapperCommit` и проверяем, совпадает ли он с хэшем в очереди: если нет, значит, внутренний tx был переупорядочен, и мы отклоняем блок.

Если проверка пройдена, то мы можем отправить внутреннюю транзакцию на исполнение в среду wasm: если транзакция подписана, то как минимум один VP проверит ее подпись на предмет возможной фальсификации данных (особенно со стороны подписанта обертки, поскольку до этого шага проверить этот конкретный случай невозможно) и, если это так, отклонит транзакцию, и никаких модификаций хранилища применяться не будет.

**В итоге:**

* Внутренний Tx несет в себе уникальный идентификатор внедренного в него оберточного Tx&#x20;
* Как внутренний, так и оберточный тх подписываются всеми своими данными.&#x20;
* Проверка подписи на оберточном тх гарантирует, что внутренняя транзакция является целевой и что эта обертка не была использована для обертывания другого внутреннего тх. Также проверяется, что внутренняя транзакция не была подделана третьей стороной. Наконец, она гарантирует, что открытый ключ принадлежит подписавшему.&#x20;
* Проверка на `WrapperCommit` гарантирует, что внутренний tx не был переупорядочен и не был повторно обернут (эта проверка не является исчерпывающей, данные внутреннего tx могли быть подделаны подписавшим обертку).&#x20;
* Проверка подписи внутреннего tx, выполняемая в Vp, гарантирует, что данные внутреннего tx не были подделаны, фактически проверяя корректность предыдущей проверки (`WrapperCommit`)

Такая последовательность элементов управления делает невозможным повторное обертывание `InnerTx`, который теперь привязан к своей обертке. Это означает, что защита от воспроизведения нужна только для `WrapperTx`, поскольку нет возможности извлечь внутренний, обернуть его и воспроизвести.

#### Проверка WrapperTx

В mempool\_validation мы выполним несколько проверок обертки tx для ее подтверждения. К ним относятся:

* Действительная подпись&#x20;
* GasLimit ниже лимита газа в блоке (подробнее см. спецификацию комиссии)
* Вознаграждение выплачивается с помощью принятого токена и соответствует минимально необходимой сумме (подробнее см. спецификацию вознаграждения)
* Действительный идентификатор цепи&#x20;
* Действительный счетчик транзакций
* Действительный срок действия

Все эти проверки могут быть выполнены до выполнения самих транзакций. Если какая-либо из этих проверок окажется неудачной, транзакцию следует считать недействительной и предпринять одно из следующих действий:

1. Если проверка подписи, chainId, срока действия или счетчика транзакций окажется неудачной, то данная транзакция будет навсегда недействительной, независимо от возможного изменения состояния ledger. Нет необходимости ни включать транзакцию в блок, ни увеличивать счетчик транзакций. Более того, мы не можем включить эту транзакцию в блок для взимания платы (в качестве своеобразного наказания), поскольку эти ошибки могут не зависеть от подписавшего tx (могут быть вызваны злоумышленниками или просто задержкой включения tx в блок).&#x20;
2. Если проверки по Fee или GasLimit не дали результата, транзакция должна быть отменена. Теоретически лимит газа в блоке является параметром Namada, контролируемым руководством, поэтому существует вероятность того, что транзакция может стать действительной в будущем, если этот лимит будет повышен. То же самое относится к белому списку токенов и минимальной требуемой комиссии. Однако мы можем ожидать медленного изменения этих параметров, поэтому мы можем отклонить транзакцию (отправитель всегда может повторно отправить ее в будущем).&#x20;
3. Если все проверки пройдут, мы включим транзакцию в блок для увеличения счетчика и взимания комиссии.

Отметим, что в отношении первого пункта следует различать недействительный счетчик `tx_counter`, который может быть недействительным из-за того, что он старый или опережающий. Для решения последней проблемы (счетчик больше ожидаемого) необходимо ввести понятие времени жизни (или таймаута) транзакций: по сути, `WrapperTx` будет содержать дополнительное поле `expiration`, указывающее максимальное время, до которого отправитель готов видеть транзакцию выполненной. По истечении указанного времени транзакция будет считаться недействительной и отбрасываться независимо от всех остальных проверок. Таким образом, в случае получения транзакции со счетчиком, превышающим ожидаемый, достаточно дождаться окончания срока действия и отправить еще несколько транзакций, чтобы счетчик в хранилище не модифицировался (остался недействительным для наблюдаемой транзакции) и повторное воспроизведение этого tx привело бы к отказу.

На самом деле это обобщается до более широкой концепции. В общем случае транзакция действительна в момент подачи, но после этого ряд внешних факторов (состояние ledger и т.д.) может изменить мнение отправителя, который уже не заинтересован в выполнении транзакции. Введя это новое поле, мы вводим новое ограничение в контракт транзакции, где ledger будет следить за тем, чтобы не допустить выполнения транзакции после истечения срока, а с другой стороны, отправитель берет на себя обязательства по результату выполнения, по крайней мере, до истечения срока. Если срок истекает, а транзакция не выполнена, отправитель может принять решение о подаче новой, идентичной транзакции, если он по-прежнему заинтересован в изменениях, которые она несет.

В нашем проекте истечение срока действия транзакции происходит до тех пор, пока она не будет выполнена, а после ее выполнения, в случае успеха или неудачи, счетчик `tx_counter` будет увеличен, и транзакция не будет воспроизводиться. По сути, отправитель транзакции берет на себя обязательство выполнить одно из этих трех условий:

* Транзакция недействительна независимо от конкретного состояния&#x20;
* Транзакция выполнена (успешно или нет), и счетчик транзакций увеличивается&#x20;
* Прошло время истечения срока действия

Первое выполненное условие делает недействительными дальнейшие выполнения того же tx.

Поскольку подписант обертки может отличаться от внутреннего, нам также необходимо включить это поле истечения срока действия в структуру `WrapperCommit`, чтобы не позволить подписантам обертки установить время жизни, противоречащее интересам внутреннего подписанта. Заметим, что добавление отдельного времени жизни только для обертки (что потребует двух отдельных проверок) не несет никакой пользы: обертка со временем жизни, превышающим внутреннее, не имеет смысла, так как внутренняя не выполнится. Ограничение времени жизни сработает, но это означает, что обертка может помешать выполнению корректной внутренней транзакции. Тогда мы оставим одно поле `expiration`, определяющее максимальное время tx обертки (внутренняя транзакция будет выполнена на один блок позже из-за механизма выполнения Namada).

Для того чтобы подписавший обертку не смог отправить транзакцию в другую цепочку, в коммит также должно быть включено поле `ChainId`.

Наконец, в случае, если у транзакции закончился бензин (на основании поля GasLimit, предоставляемого оберткой), нам не нужно предпринимать никаких действий: к этому моменту счетчик транзакций уже будет увеличен, и tx больше не будет воспроизводиться. Теоретически нам даже не нужно инкрементировать счетчик, поскольку единственным способом сделать транзакцию действительной может быть изменение способа учета газа, что в любом случае потребует форка, а следовательно, и изменения требуемого `ChainId`. Однако, поскольку мы не можем определить расход газа до выполнения внутреннего tx, мы не можем предвидеть эту проверку.

Все эти проверки выполняются и в `process_proposal` с добавлением: валидаторы также проверяют, достаточно ли средств у подписанта обертки для оплаты комиссии. Эта проверка не должна выполняться в mempool, поскольку средства, доступные для определенного адреса, являются переменными во времени и должны проверяться только во время включения блока. Если какая-либо из проверок не проходит, то весь блок отклоняется, заставляя начать новый раунд Tendermint (см. более подробное объяснение этого выбора в разделе).

Параметр `expiration` также оправдывает то, что проверка средств выполняется только в `process_proposal`, а не в mempool. Без этого параметра транзакция могла бы быть выполнена в любой момент в будущем, возможно, вопреки мутировавшим интересам подателя. Теперь, с параметром `expiration`, податель обязуется принять исполнение транзакции до указанного времени: в его обязанности будет входить обеспечение разумного значения этого параметра. При таком ограничении транзакция будет храниться в mempool до истечения срока действия (поскольку после этого она в любом случае станет недействительной), чтобы не допустить чрезмерного увеличения размера mempool.

Этот механизм можно применить и к другому сценарию. Предположим, что транзакция не была передана в сеть узлом (или группой сговорившихся узлов). Теперь эта транзакция может быть действительной, но она не будет вставлена в блок. Без истечения срока действия, если отправитель не отправит никакой другой транзакции (которая будет включена в блок для увеличения счетчика транзакций), эта tx может быть воспроизведена (лучше, применена, поскольку она никогда не была выполнена) в будущий момент времени, когда отправитель, возможно, уже не захочет ее выполнять.

### WrapperCommit

Поля `WrapperTx`, не включенные в `WrapperCommit`, определяются по усмотрению производителя `WrapperTx`. Эти поля не включаются в коммит по одной из двух причин:

* Они зависят от конкретного состояния подписанта обертки и не могут быть принудительными (как, например, плата, поскольку подписант обертки должен иметь достаточно средств для ее оплаты)&#x20;
* Они не представляют угрозы (с точки зрения атак повторного воспроизведения) для подписанта внутренней транзакции в случае ее сбоя&#x20;

В определенном смысле `WrapperCommit` не только связывает внутреннюю транзакцию с оберткой, но и позволяет внутренней транзакции управлять оберткой, запрашивая определенные параметры для ее создания, и связывать эти параметры между двумя транзакциями: это позволяет нам применять одинаковые ограничения к обеим транзакциям, выполняя проверки только на обертке.

### Процесс создания транзакции&#x20;

Для создания транзакции процесс будет выглядеть следующим образом (дополнительные шаги необходимы только в том случае, если подписант внутренней подписи отличается от подписанта обертки):

* (Необязательно) запрос конструктора `InnerTx` к подписавшему обертку, его открытый ключ и используемый счетчик `tx_counter`.
* `InnerTx` конструируется целиком, включая также поле `wrapper_commit` для определения ограничений будущей обертки.&#x20;
* Созданная структура Tx подписывается над всеми своими данными (с помощью `SignedTxData`), создавая новую структуру Tx&#x20;
* (Необязательно) созданный внутренний tx отправляется производителю `WrapperTx` вместе со структурой `WrapperCommit` (необходимо, так как внутренний tx содержит только хэш от него).&#x20;
* Подписывающая сторона обертки создает `WrapperTx`, соответствующий полям `WrapperCommit`.&#x20;
* Созданный `WrapperTx` подписывается по всем своим полям

По сравнению с решением, не связывающим внутренний tx с оберточным, это решение требует обмена 3 сообщениями (запрос `tx_counter`, получение `tx_counter`, отправка `InnerTx`) между двумя подписантами (в случае их различия), а не одним. Однако это позволяет подписавшему внутреннюю транзакцию отправлять `InnerTx` подписавшему обертку уже зашифрованным, что гарантирует более высокий уровень безопасности: в открытом виде должна быть отправлена только структура `WrapperCommit`, но это не раскрывает никакой конфиденциальной информации о самой внутренней транзакции.
